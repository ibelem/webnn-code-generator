{
  "identifier": "mobilenetv2_fp16.onnx",
  "format": "ONNX v6",
  "graph": [
    {
      "name": "torch-jit-export",
      "inputs": [
        {
          "name": "pixel_values",
          "value": [
            {
              "name": "pixel_values",
              "type": {
                "dataType": "float32",
                "shape": {
                  "dimensions": [
                    1,
                    3,
                    224,
                    224
                  ]
                }
              }
            }
          ]
        }
      ],
      "outputs": [
        {
          "name": "logits",
          "value": [
            {
              "name": "logits",
              "type": {
                "dataType": "float32",
                "shape": {
                  "dimensions": [
                    1,
                    1000
                  ]
                }
              }
            }
          ]
        }
      ],
      "nodes": [
        {
          "name": "graph_input_cast0",
          "chain": [],
          "metadata": [],
          "inputs": [
            {
              "name": "input",
              "value": [
                {
                  "name": "pixel_values",
                  "type": {
                    "dataType": "float32",
                    "shape": {
                      "dimensions": [
                        1,
                        3,
                        224,
                        224
                      ]
                    }
                  }
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "output",
              "value": [
                {
                  "name": "graph_input_cast_0"
                }
              ]
            }
          ],
          "attributes": [
            {
              "name": "to",
              "type": "DataType",
              "value": "float16"
            }
          ],
          "type": {
            "name": "Cast",
            "module": "ai.onnx",
            "version": 9,
            "description": "The operator casts the elements of a given input tensor to a data type\nspecified by the 'to' argument and returns an output tensor of the same size in\nthe converted type. The 'to' argument must be one of the data types specified\nin the 'DataType' enum field in the TensorProto message.\n\nCasting from string tensor in plain (e.g., \"3.14\" and \"1000\") and scientific numeric representations\n(e.g., \"1e-5\" and \"1E8\") to float types is supported. For example, converting string \"100.5\" to an integer may\nyield result 100. There are some string literals reserved for special floating-point values;\n\"+INF\" (and \"INF\"), \"-INF\", and \"NaN\" are positive infinity, negative infinity, and not-a-number, respectively.\nAny string which can exactly match \"+INF\" in a case-insensitive way would be mapped to positive infinite. Similarly,\nthis case-insensitive rule is applied to \"INF\" and \"NaN\". When casting from numeric tensors\nto string tensors, plain floating-point representation (such as \"314.15926\") would be used.\nConverting non-numerical-literal string such as \"Hello World!\" is an undefined behavior. Cases\nof converting string representing floating-point arithmetic value, such as \"2.718\", to INT is an undefined behavior.\n\nConversion from a numerical type to any numerical type is always allowed.\nUser must be aware of precision loss and value change caused by range difference between two types.\nFor example, a 64-bit float 3.1415926459 may be round to a 32-bit float 3.141592. Similarly, converting\nan integer 36 to Boolean may produce 1 because we truncate bits which can't be stored in the targeted type.\n",
            "attributes": [
              {
                "name": "to",
                "type": "DataType",
                "required": true,
                "description": "The data type to which the elements of the input tensor are cast. Strictly must be one of the types from DataType enum in TensorProto"
              }
            ],
            "inputs": [
              {
                "name": "input",
                "type": "T1",
                "description": "Input tensor to be cast."
              }
            ],
            "min_input": 1,
            "max_input": 1,
            "outputs": [
              {
                "name": "output",
                "type": "T2",
                "description": "Output tensor with the same shape as input with type specified by the 'to' argument"
              }
            ],
            "min_output": 1,
            "max_output": 1,
            "type_constraints": [
              {
                "description": "Constrain input types. Casting from complex is not supported.",
                "type_param_str": "T1",
                "allowed_type_strs": [
                  "tensor(float16)",
                  "tensor(float)",
                  "tensor(double)",
                  "tensor(int8)",
                  "tensor(int16)",
                  "tensor(int32)",
                  "tensor(int64)",
                  "tensor(uint8)",
                  "tensor(uint16)",
                  "tensor(uint32)",
                  "tensor(uint64)",
                  "tensor(bool)",
                  "tensor(string)"
                ]
              },
              {
                "description": "Constrain output types. Casting to complex is not supported.",
                "type_param_str": "T2",
                "allowed_type_strs": [
                  "tensor(float16)",
                  "tensor(float)",
                  "tensor(double)",
                  "tensor(int8)",
                  "tensor(int16)",
                  "tensor(int32)",
                  "tensor(int64)",
                  "tensor(uint8)",
                  "tensor(uint16)",
                  "tensor(uint32)",
                  "tensor(uint64)",
                  "tensor(bool)",
                  "tensor(string)"
                ]
              }
            ],
            "examples": [
              {
                "summary": "cast",
                "code": "shape = (3, 4)\ntest_cases = [\n    (\"FLOAT\", \"FLOAT16\"),\n    (\"FLOAT\", \"DOUBLE\"),\n    (\"FLOAT16\", \"FLOAT\"),\n    (\"FLOAT16\", \"DOUBLE\"),\n    (\"DOUBLE\", \"FLOAT\"),\n    (\"DOUBLE\", \"FLOAT16\"),\n    (\"FLOAT\", \"STRING\"),\n    (\"STRING\", \"FLOAT\"),\n    (\"FLOAT\", \"BFLOAT16\"),\n    (\"BFLOAT16\", \"FLOAT\"),\n    (\"FLOAT\", \"FLOAT8E4M3FN\"),\n    (\"FLOAT16\", \"FLOAT8E4M3FN\"),\n    (\"FLOAT\", \"FLOAT8E4M3FNUZ\"),\n    (\"FLOAT16\", \"FLOAT8E4M3FNUZ\"),\n    (\"FLOAT8E4M3FN\", \"FLOAT\"),\n    (\"FLOAT8E4M3FN\", \"FLOAT16\"),\n    (\"FLOAT8E4M3FNUZ\", \"FLOAT\"),\n    (\"FLOAT8E4M3FNUZ\", \"FLOAT16\"),\n    (\"FLOAT\", \"FLOAT8E5M2\"),\n    (\"FLOAT16\", \"FLOAT8E5M2\"),\n    (\"FLOAT\", \"FLOAT8E5M2FNUZ\"),\n    (\"FLOAT16\", \"FLOAT8E5M2FNUZ\"),\n    (\"FLOAT8E5M2\", \"FLOAT\"),\n    (\"FLOAT8E5M2\", \"FLOAT16\"),\n    (\"FLOAT8E5M2FNUZ\", \"FLOAT\"),\n    (\"FLOAT8E5M2FNUZ\", \"FLOAT16\"),\n    (\"FLOAT\", \"UINT4\"),\n    (\"FLOAT16\", \"UINT4\"),\n    (\"FLOAT\", \"INT4\"),\n    (\"FLOAT16\", \"INT4\"),\n    (\"UINT4\", \"FLOAT\"),\n    (\"UINT4\", \"FLOAT16\"),\n    (\"UINT4\", \"UINT8\"),\n    (\"INT4\", \"FLOAT\"),\n    (\"INT4\", \"FLOAT16\"),\n    (\"INT4\", \"INT8\"),\n    (\"FLOAT4E2M1\", \"FLOAT\"),\n    (\"FLOAT4E2M1\", \"FLOAT16\"),\n    (\"FLOAT\", \"FLOAT4E2M1\"),\n    (\"FLOAT16\", \"FLOAT4E2M1\"),\n]\n\nvect_float32_to_float8e4m3 = np.vectorize(float32_to_float8e4m3)\nvect_float32_to_float8e5m2 = np.vectorize(float32_to_float8e5m2)\nvect_float32_to_uint4 = np.vectorize(\n    lambda x: subbyte.float32_to_4bit_unpacked(x, signed=False)\n)\nvect_float32_to_int4 = np.vectorize(\n    lambda x: subbyte.float32_to_4bit_unpacked(x, signed=True)\n)\n\nf8_types = (\"FLOAT8E4M3FN\", \"FLOAT8E4M3FNUZ\", \"FLOAT8E5M2\", \"FLOAT8E5M2FNUZ\")\n\nfor from_type, to_type in test_cases:\n    input_type_proto = None\n    output_type_proto = None\n    if from_type == \"BFLOAT16\" or to_type == \"BFLOAT16\":\n        np_fp32 = np.array(\n            [\n                \"0.47892547\",\n                \"0.48033667\",\n                \"0.49968487\",\n                \"0.81910545\",\n                \"0.47031248\",\n                \"0.816468\",\n                \"0.21087195\",\n                \"0.7229038\",\n                \"NaN\",\n                \"INF\",\n                \"+INF\",\n                \"-INF\",\n            ],\n            dtype=np.float32,\n        )\n        little_endisan = sys.byteorder == \"little\"\n        np_uint16_view = np_fp32.view(dtype=np.uint16)\n        np_bfp16 = (\n            np_uint16_view[1::2] if little_endisan else np_uint16_view[0::2]\n        )\n        if to_type == \"BFLOAT16\":\n            assert from_type == \"FLOAT\"\n            input = np_fp32.reshape([3, 4])\n            output = np_bfp16.reshape([3, 4])\n            input_type_proto = onnx.helper.make_tensor_type_proto(\n                int(TensorProto.FLOAT), input.shape\n            )\n            output_type_proto = onnx.helper.make_tensor_type_proto(\n                int(TensorProto.BFLOAT16), output.shape\n            )\n        else:\n            assert to_type == \"FLOAT\"\n            input = np_bfp16.reshape([3, 4])\n            # convert bfloat to FLOAT\n            np_fp32_zeros = np.zeros((len(np_bfp16) * 2,), dtype=np.uint16)\n            if little_endisan:\n                np_fp32_zeros[1::2] = np_bfp16\n            else:\n                np_fp32_zeros[0::2] = np_bfp16\n            np_fp32_from_bfloat = np_fp32_zeros.view(dtype=np.float32)\n            output = np_fp32_from_bfloat.reshape([3, 4])\n            input_type_proto = onnx.helper.make_tensor_type_proto(\n                int(TensorProto.BFLOAT16), input.shape\n            )\n            output_type_proto = onnx.helper.make_tensor_type_proto(\n                int(TensorProto.FLOAT), output.shape\n            )\n    elif from_type in f8_types or to_type in f8_types:\n        np_fp32 = np.array(\n            [\n                \"0.47892547\",\n                \"0.48033667\",\n                \"0.49968487\",\n                \"0.81910545\",\n                \"0.47031248\",\n                \"0.7229038\",\n                \"1000000\",\n                \"1e-7\",\n                \"NaN\",\n                \"INF\",\n                \"+INF\",\n                \"-INF\",\n                \"-0.0000001\",\n                \"0.0000001\",\n                \"-1000000\",\n            ],\n            dtype=np.float32,\n        )\n\n        if from_type == \"FLOAT\":\n            input_values = np_fp32\n            input = make_tensor(\n                \"x\", TensorProto.FLOAT, [3, 5], np_fp32.tolist()\n            )\n        elif from_type == \"FLOAT16\":\n            input_values = np_fp32.astype(np.float16).astype(np.float32)\n            input = make_tensor(\n                \"x\", TensorProto.FLOAT16, [3, 5], input_values.tolist()\n            )\n        elif from_type == \"FLOAT8E4M3FN\":\n            input_values = float8e4m3_to_float32(\n                vect_float32_to_float8e4m3(np_fp32)\n            )\n            input = make_tensor(\n                \"x\", TensorProto.FLOAT8E4M3FN, [3, 5], input_values.tolist()\n            )\n        elif from_type == \"FLOAT8E4M3FNUZ\":\n            input_values = float8e4m3_to_float32(\n                vect_float32_to_float8e4m3(np_fp32, uz=True), uz=True\n            )\n            input = make_tensor(\n                \"x\", TensorProto.FLOAT8E4M3FNUZ, [3, 5], input_values.tolist()\n            )\n        elif from_type == \"FLOAT8E5M2\":\n            input_values = float8e5m2_to_float32(\n                vect_float32_to_float8e5m2(np_fp32)\n            )\n            input = make_tensor(\n                \"x\", TensorProto.FLOAT8E5M2, [3, 5], input_values.tolist()\n            )\n        elif from_type == \"FLOAT8E5M2FNUZ\":\n            input_values = float8e5m2_to_float32(\n                vect_float32_to_float8e5m2(np_fp32, fn=True, uz=True),\n                fn=True,\n                uz=True,\n            )\n            input = make_tensor(\n                \"x\", TensorProto.FLOAT8E5M2FNUZ, [3, 5], input_values.tolist()\n            )\n        else:\n            raise ValueError(\n                \"Conversion from {from_type} to {to_type} is not tested.\"\n            )\n\n        if to_type == \"FLOAT8E4M3FN\":\n            expected = float8e4m3_to_float32(\n                vect_float32_to_float8e4m3(input_values)\n            )\n        elif to_type == \"FLOAT8E4M3FNUZ\":\n            expected = float8e4m3_to_float32(\n                vect_float32_to_float8e4m3(input_values, uz=True), uz=True\n            )\n        elif to_type == \"FLOAT8E5M2\":\n            expected = float8e5m2_to_float32(\n                vect_float32_to_float8e5m2(input_values)\n            )\n        elif to_type == \"FLOAT8E5M2FNUZ\":\n            expected = float8e5m2_to_float32(\n                vect_float32_to_float8e5m2(input_values, fn=True, uz=True),\n                fn=True,\n                uz=True,\n            )\n        elif to_type == \"FLOAT16\":\n            expected = input_values.astype(np.float16).astype(np.float32)\n        elif to_type == \"FLOAT\":\n            expected = input_values\n        else:\n            raise ValueError(\n                \"Conversion from {from_type} to {to_type} is not tested.\"\n            )\n        expected_tensor = make_tensor(\n            \"x\", getattr(TensorProto, to_type), [3, 5], expected.tolist()\n        )\n        output = expected_tensor\n    elif from_type in (\"UINT4\", \"INT4\") or to_type in (\"UINT4\", \"INT4\"):\n        np_fp32 = np.arange(-9, 16).astype(np.float32)\n        input_shape = (5, 5)\n        if from_type == \"FLOAT\":\n            input_values = np_fp32\n            input = make_tensor(\n                \"x\", TensorProto.FLOAT, input_shape, input_values.tolist()\n            )\n        elif from_type == \"FLOAT16\":\n            input_values = np_fp32.astype(np.float16)\n            input = make_tensor(\n                \"x\", TensorProto.FLOAT16, input_shape, input_values.tolist()\n            )\n        elif from_type == \"UINT4\":\n            input_values = vect_float32_to_uint4(np_fp32)\n            input = make_tensor(\n                \"x\", TensorProto.UINT4, input_shape, input_values.tolist()\n            )\n        elif from_type == \"INT4\":\n            input_values = vect_float32_to_int4(np_fp32)\n            input = make_tensor(\n                \"x\", TensorProto.INT4, input_shape, input_values.tolist()\n            )\n        else:\n            raise ValueError(\n                \"Conversion from {from_type} to {to_type} is not tested.\"\n            )\n        if to_type == \"UINT4\":\n            expected = vect_float32_to_uint4(input_values).astype(custom.uint4)\n        elif to_type == \"INT4\":\n            expected = vect_float32_to_int4(input_values).astype(custom.int4)\n        elif to_type == \"FLOAT16\":\n            expected = input_values.astype(np.float16)\n        elif to_type == \"FLOAT\":\n            expected = input_values\n        elif to_type == \"UINT8\":\n            expected = input_values.astype(np.uint8)\n        elif to_type == \"INT8\":\n            expected = input_values.astype(np.int8)\n        else:\n            raise ValueError(\n                \"Conversion from {from_type} to {to_type} is not tested.\"\n            )\n        expected_tensor = make_tensor(\n            \"y\", getattr(TensorProto, to_type), input_shape, expected.tolist()\n        )\n        output = expected_tensor\n        input_type_proto = onnx.helper.make_tensor_type_proto(\n            getattr(TensorProto, from_type), input_shape\n        )\n        output_type_proto = onnx.helper.make_tensor_type_proto(\n            getattr(TensorProto, to_type), input_shape\n        )\n    elif from_type == \"FLOAT4E2M1\" or to_type == \"FLOAT4E2M1\":\n        np_fp32 = np.array(\n            [\n                \"0.48\",\n                \"0.25\",\n                \"1.05\",\n                \"-3.5\",\n                \"-8\",\n                \"9\",\n                \"1000000\",\n                \"1e-7\",\n                \"NaN\",\n                \"INF\",\n                \"+INF\",\n                \"-INF\",\n                \"-4\",\n                \"0.01\",\n                \"-0.0\",\n            ],\n            dtype=np.float32,\n        )\n        input_shape = (3, 5)\n        if from_type == \"FLOAT\":\n            input_values = np_fp32\n            input = make_tensor(\n                \"x\", TensorProto.FLOAT, input_shape, input_values.tolist()\n            )\n        elif from_type == \"FLOAT16\":\n            input_values = np_fp32.astype(np.float16).astype(np.float32)\n            input = make_tensor(\n                \"x\", TensorProto.FLOAT16, input_shape, input_values.tolist()\n            )\n        elif from_type == \"FLOAT4E2M1\":\n            input = make_tensor(\n                \"x\", TensorProto.FLOAT4E2M1, input_shape, np_fp32.tolist()\n            )\n        else:\n            raise ValueError(\n                f\"Conversion from {from_type} to {to_type} is not tested.\"\n            )\n\n        if to_type not in (\"FLOAT\", \"FLOAT16\", \"FLOAT4E2M1\"):\n            raise ValueError(\n                f\"Conversion from {from_type} to {to_type} is not tested.\"\n            )\n        expected = unpacked_float4e2m1_to_float32(\n            subbyte.float32_to_float4e2m1_unpacked(np_fp32)\n        )\n        output = make_tensor(\n            \"y\", getattr(TensorProto, to_type), input_shape, expected.tolist()\n        )\n    elif from_type != \"STRING\":\n        input = np.random.random_sample(shape).astype(\n            helper.tensor_dtype_to_np_dtype(getattr(TensorProto, from_type))\n        )\n        if to_type == \"STRING\":\n            # Converting input to str, then give it object dtype for generating script\n            ss = []\n            for i in input.flatten():\n                s = str(i).encode(\"utf-8\")\n                su = s.decode(\"utf-8\")\n                ss.append(su)\n\n            output = np.array(ss).astype(object).reshape([3, 4])\n        else:\n            output = input.astype(\n                helper.tensor_dtype_to_np_dtype(getattr(TensorProto, to_type))\n            )\n    else:\n        input = np.array(\n            [\n                \"0.47892547\",\n                \"0.48033667\",\n                \"0.49968487\",\n                \"0.81910545\",\n                \"0.47031248\",\n                \"0.816468\",\n                \"0.21087195\",\n                \"0.7229038\",\n                \"NaN\",\n                \"INF\",\n                \"+INF\",\n                \"-INF\",\n            ],\n            dtype=np.dtype(object),\n        ).reshape([3, 4])\n        output = input.astype(\n            helper.tensor_dtype_to_np_dtype(getattr(TensorProto, to_type))\n        )\n    node = onnx.helper.make_node(\n        \"Cast\",\n        inputs=[\"input\"],\n        outputs=[\"output\"],\n        to=getattr(TensorProto, to_type),\n    )\n    if input_type_proto and output_type_proto:\n        expect(\n            node,\n            inputs=[input],\n            outputs=[output],\n            name=\"test_cast_\" + from_type + \"_to_\" + to_type,\n            input_type_protos=[input_type_proto],\n            output_type_protos=[output_type_proto],\n        )\n    else:\n        expect(\n            node,\n            inputs=[input],\n            outputs=[output],\n            name=\"test_cast_\" + from_type + \"_to_\" + to_type,\n        )"
              },
              {
                "summary": "saturate_false",
                "code": "test_cases = [\n    (\"FLOAT\", \"FLOAT8E4M3FN\"),\n    (\"FLOAT16\", \"FLOAT8E4M3FN\"),\n    (\"FLOAT\", \"FLOAT8E4M3FNUZ\"),\n    (\"FLOAT16\", \"FLOAT8E4M3FNUZ\"),\n    (\"FLOAT\", \"FLOAT8E5M2\"),\n    (\"FLOAT16\", \"FLOAT8E5M2\"),\n    (\"FLOAT\", \"FLOAT8E5M2FNUZ\"),\n    (\"FLOAT16\", \"FLOAT8E5M2FNUZ\"),\n]\nvect_float32_to_float8e4m3 = np.vectorize(float32_to_float8e4m3)\nvect_float32_to_float8e5m2 = np.vectorize(float32_to_float8e5m2)\n\nfor from_type, to_type in test_cases:\n    np_fp32 = np.array(\n        [\n            \"0.47892547\",\n            \"0.48033667\",\n            \"0.49968487\",\n            \"0.81910545\",\n            \"0.47031248\",\n            \"0.7229038\",\n            \"1000000\",\n            \"1e-7\",\n            \"NaN\",\n            \"INF\",\n            \"+INF\",\n            \"-INF\",\n            \"-0.0000001\",\n            \"0.0000001\",\n            \"-1000000\",\n        ],\n        dtype=np.float32,\n    )\n\n    if from_type == \"FLOAT\":\n        input_values = np_fp32\n        input = make_tensor(\"x\", TensorProto.FLOAT, [3, 5], np_fp32.tolist())\n    elif from_type == \"FLOAT16\":\n        input_values = np_fp32.astype(np.float16).astype(np.float32)\n        input = make_tensor(\n            \"x\", TensorProto.FLOAT16, [3, 5], input_values.tolist()\n        )\n    else:\n        raise ValueError(\n            \"Conversion from {from_type} to {to_type} is not tested.\"\n        )\n\n    if to_type == \"FLOAT8E4M3FN\":\n        expected = vect_float32_to_float8e4m3(input_values, saturate=False)\n    elif to_type == \"FLOAT8E4M3FNUZ\":\n        expected = vect_float32_to_float8e4m3(\n            input_values, uz=True, saturate=False\n        )\n    elif to_type == \"FLOAT8E5M2\":\n        expected = vect_float32_to_float8e5m2(input_values, saturate=False)\n    elif to_type == \"FLOAT8E5M2FNUZ\":\n        expected = vect_float32_to_float8e5m2(\n            input_values, fn=True, uz=True, saturate=False\n        )\n    else:\n        raise ValueError(\n            \"Conversion from {from_type} to {to_type} is not tested.\"\n        )\n\n    ivals = bytes([int(i) for i in expected])\n    tensor = TensorProto()\n    tensor.data_type = getattr(TensorProto, to_type)\n    tensor.name = \"x\"\n    tensor.dims.extend([3, 5])\n    field = tensor_dtype_to_field(tensor.data_type)\n    getattr(tensor, field).extend(ivals)\n\n    output = tensor\n\n    node = onnx.helper.make_node(\n        \"Cast\",\n        inputs=[\"input\"],\n        outputs=[\"output\"],\n        to=getattr(TensorProto, to_type),\n        saturate=0,\n    )\n    expect(\n        node,\n        inputs=[input],\n        outputs=[output],\n        name=\"test_cast_no_saturate_\" + from_type + \"_to_\" + to_type,\n    )"
              }
            ]
          }
        },
        {
          "name": "Conv_0",
          "chain": [],
          "metadata": [],
          "inputs": [
            {
              "name": "X",
              "value": [
                {
                  "name": "graph_input_cast_0"
                }
              ]
            },
            {
              "name": "W",
              "value": [
                {
                  "name": "475",
                  "initializer": {
                    "name": "475",
                    "category": "Initializer",
                    "encoding": "<",
                    "type": {
                      "dataType": "float16",
                      "shape": {
                        "dimensions": [
                          32,
                          3,
                          3,
                          3
                        ]
                      }
                    }
                  },
                  "type": {
                    "dataType": "float16",
                    "shape": {
                      "dimensions": [
                        32,
                        3,
                        3,
                        3
                      ]
                    }
                  }
                }
              ]
            },
            {
              "name": "B",
              "value": [
                {
                  "name": "476",
                  "initializer": {
                    "name": "476",
                    "category": "Initializer",
                    "encoding": "<",
                    "type": {
                      "dataType": "float16",
                      "shape": {
                        "dimensions": [
                          32
                        ]
                      }
                    }
                  },
                  "type": {
                    "dataType": "float16",
                    "shape": {
                      "dimensions": [
                        32
                      ]
                    }
                  }
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "Y",
              "value": [
                {
                  "name": "474"
                }
              ]
            }
          ],
          "attributes": [
            {
              "name": "dilations",
              "type": "int64[]",
              "value": {
                "type": "bigint[]",
                "value": [
                  "1",
                  "1"
                ]
              }
            },
            {
              "name": "group",
              "type": "int64",
              "value": {
                "type": "bigint",
                "value": "1"
              }
            },
            {
              "name": "kernel_shape",
              "type": "int64[]",
              "value": {
                "type": "bigint[]",
                "value": [
                  "3",
                  "3"
                ]
              }
            },
            {
              "name": "pads",
              "type": "int64[]",
              "value": {
                "type": "bigint[]",
                "value": [
                  "1",
                  "1",
                  "1",
                  "1"
                ]
              }
            },
            {
              "name": "strides",
              "type": "int64[]",
              "value": {
                "type": "bigint[]",
                "value": [
                  "2",
                  "2"
                ]
              }
            }
          ],
          "type": {
            "name": "Conv",
            "module": "ai.onnx",
            "version": 1,
            "description": "The convolution operator consumes an input tensor and a filter, and\ncomputes the output.",
            "attributes": [
              {
                "name": "auto_pad",
                "type": "string",
                "required": false,
                "default": "NOTSET",
                "description": "auto_pad must be either NOTSET, SAME_UPPER, SAME_LOWER or VALID. Where default value is NOTSET, which means explicit padding is used. SAME_UPPER or SAME_LOWER mean pad the input so that the output spatial size match the input.In case of odd number add the extra padding at the end for SAME_UPPER and at the beginning for SAME_LOWER. VALID mean no padding."
              },
              {
                "name": "dilations",
                "type": "int64[]",
                "required": false,
                "description": "dilation value along each spatial axis of the filter."
              },
              {
                "name": "group",
                "type": "int64",
                "required": false,
                "default": 1,
                "description": "number of groups input channels and output channels are divided into."
              },
              {
                "name": "kernel_shape",
                "type": "int64[]",
                "required": false,
                "description": "The shape of the convolution kernel. If not present, should be inferred from input W."
              },
              {
                "name": "pads",
                "type": "int64[]",
                "required": false,
                "description": "Padding for the beginning and ending along each spatial axis, it can take any value greater than or equal to 0. The value represent the number of pixels added to the beginning and end part of the corresponding axis. `pads` format should be as follow [x1_begin, x2_begin...x1_end, x2_end,...], where xi_begin the number of pixels added at the beginning of axis `i` and xi_end, the number of pixels added at the end of axis `i`. This attribute cannot be used simultaneously with auto_pad attribute. If not present, the padding defaults to 0 along start and end of each spatial axis."
              },
              {
                "name": "strides",
                "type": "int64[]",
                "required": false,
                "description": "Stride along each spatial axis."
              }
            ],
            "inputs": [
              {
                "name": "X",
                "type": "T",
                "description": "Input data tensor from previous layer; has size (N x C x H x W), where N is the batch size, C is the number of channels, and H and W are the height and width. Note that this is for the 2D image. Otherwise the size is (N x C x D1 x D2 ... x Dn). Optionally, if dimension denotation is in effect, the operation expects input data tensor to arrive with the dimension denotation of [DATA_BATCH, DATA_CHANNEL, DATA_FEATURE, DATA_FEATURE ...]."
              },
              {
                "name": "W",
                "type": "T",
                "description": "The weight tensor that will be used in the convolutions; has size (M x C/group x kH x kW), where C is the number of channels, and kH and kW are the height and width of the kernel, and M is the number of feature maps. For more than 2 dimensions, the kernel shape will be (M x C/group x k1 x k2 x ... x kn), where (k1 x k2 x ... kn) is the dimension of the kernel. Optionally, if dimension denotation is in effect, the operation expects the weight tensor to arrive with the dimension denotation of [FILTER_OUT_CHANNEL, FILTER_IN_CHANNEL, FILTER_SPATIAL, FILTER_SPATIAL ...]. X.shape[1] == (W.shape[1] * group) == C (assuming zero based indices for the shape array). Or in other words FILTER_IN_CHANNEL should be equal to DATA_CHANNEL. "
              },
              {
                "name": "B",
                "type": "T",
                "option": "optional",
                "description": "Optional 1D bias to be added to the convolution, has size of M."
              }
            ],
            "min_input": 2,
            "max_input": 3,
            "outputs": [
              {
                "name": "Y",
                "type": "T",
                "description": "Output data tensor that contains the result of the convolution. The output dimensions are functions of the kernel size, stride size, and pad lengths."
              }
            ],
            "min_output": 1,
            "max_output": 1,
            "inputs_range": "2 - 3",
            "type_constraints": [
              {
                "description": "Constrain input and output types to float tensors.",
                "type_param_str": "T",
                "allowed_type_strs": [
                  "tensor(float16)",
                  "tensor(float)",
                  "tensor(double)"
                ]
              }
            ],
            "examples": [
              {
                "summary": "conv",
                "code": "x = np.array(\n    [\n        [\n            [\n                [0.0, 1.0, 2.0, 3.0, 4.0],  # (1, 1, 5, 5) input tensor\n                [5.0, 6.0, 7.0, 8.0, 9.0],\n                [10.0, 11.0, 12.0, 13.0, 14.0],\n                [15.0, 16.0, 17.0, 18.0, 19.0],\n                [20.0, 21.0, 22.0, 23.0, 24.0],\n            ]\n        ]\n    ]\n).astype(np.float32)\nW = np.array(\n    [\n        [\n            [\n                [1.0, 1.0, 1.0],  # (1, 1, 3, 3) tensor for convolution weights\n                [1.0, 1.0, 1.0],\n                [1.0, 1.0, 1.0],\n            ]\n        ]\n    ]\n).astype(np.float32)\n\n# Convolution with padding\nnode_with_padding = onnx.helper.make_node(\n    \"Conv\",\n    inputs=[\"x\", \"W\"],\n    outputs=[\"y\"],\n    kernel_shape=[3, 3],\n    # Default values for other attributes: strides=[1, 1], dilations=[1, 1], groups=1\n    pads=[1, 1, 1, 1],\n)\ny_with_padding = np.array(\n    [\n        [\n            [\n                [12.0, 21.0, 27.0, 33.0, 24.0],  # (1, 1, 5, 5) output tensor\n                [33.0, 54.0, 63.0, 72.0, 51.0],\n                [63.0, 99.0, 108.0, 117.0, 81.0],\n                [93.0, 144.0, 153.0, 162.0, 111.0],\n                [72.0, 111.0, 117.0, 123.0, 84.0],\n            ]\n        ]\n    ]\n).astype(np.float32)\nexpect(\n    node_with_padding,\n    inputs=[x, W],\n    outputs=[y_with_padding],\n    name=\"test_basic_conv_with_padding\",\n)\n\n# Convolution without padding\nnode_without_padding = onnx.helper.make_node(\n    \"Conv\",\n    inputs=[\"x\", \"W\"],\n    outputs=[\"y\"],\n    kernel_shape=[3, 3],\n    # Default values for other attributes: strides=[1, 1], dilations=[1, 1], groups=1\n    pads=[0, 0, 0, 0],\n)\ny_without_padding = np.array(\n    [\n        [\n            [\n                [54.0, 63.0, 72.0],  # (1, 1, 3, 3) output tensor\n                [99.0, 108.0, 117.0],\n                [144.0, 153.0, 162.0],\n            ]\n        ]\n    ]\n).astype(np.float32)\nexpect(\n    node_without_padding,\n    inputs=[x, W],\n    outputs=[y_without_padding],\n    name=\"test_basic_conv_without_padding\",\n)"
              },
              {
                "summary": "conv_with_autopad_same",
                "code": "x = np.array(\n    [\n        [\n            [\n                [0.0, 1.0, 2.0, 3.0, 4.0],  # (1, 1, 5, 5) input tensor\n                [5.0, 6.0, 7.0, 8.0, 9.0],\n                [10.0, 11.0, 12.0, 13.0, 14.0],\n                [15.0, 16.0, 17.0, 18.0, 19.0],\n                [20.0, 21.0, 22.0, 23.0, 24.0],\n            ]\n        ]\n    ]\n).astype(np.float32)\nW = np.array(\n    [\n        [\n            [\n                [1.0, 1.0, 1.0],  # (1, 1, 3, 3) tensor for convolution weights\n                [1.0, 1.0, 1.0],\n                [1.0, 1.0, 1.0],\n            ]\n        ]\n    ]\n).astype(np.float32)\n\n# Convolution with auto_pad='SAME_LOWER' and strides=2\nnode = onnx.helper.make_node(\n    \"Conv\",\n    inputs=[\"x\", \"W\"],\n    outputs=[\"y\"],\n    auto_pad=\"SAME_LOWER\",\n    kernel_shape=[3, 3],\n    strides=[2, 2],\n)\ny = np.array(\n    [[[[12.0, 27.0, 24.0], [63.0, 108.0, 81.0], [72.0, 117.0, 84.0]]]]\n).astype(np.float32)\nexpect(node, inputs=[x, W], outputs=[y], name=\"test_conv_with_autopad_same\")"
              },
              {
                "summary": "conv_with_strides",
                "code": "x = np.array(\n    [\n        [\n            [\n                [0.0, 1.0, 2.0, 3.0, 4.0],  # (1, 1, 7, 5) input tensor\n                [5.0, 6.0, 7.0, 8.0, 9.0],\n                [10.0, 11.0, 12.0, 13.0, 14.0],\n                [15.0, 16.0, 17.0, 18.0, 19.0],\n                [20.0, 21.0, 22.0, 23.0, 24.0],\n                [25.0, 26.0, 27.0, 28.0, 29.0],\n                [30.0, 31.0, 32.0, 33.0, 34.0],\n            ]\n        ]\n    ]\n).astype(np.float32)\nW = np.array(\n    [\n        [\n            [\n                [1.0, 1.0, 1.0],  # (1, 1, 3, 3) tensor for convolution weights\n                [1.0, 1.0, 1.0],\n                [1.0, 1.0, 1.0],\n            ]\n        ]\n    ]\n).astype(np.float32)\n\n# Convolution with strides=2 and padding\nnode_with_padding = onnx.helper.make_node(\n    \"Conv\",\n    inputs=[\"x\", \"W\"],\n    outputs=[\"y\"],\n    kernel_shape=[3, 3],\n    pads=[1, 1, 1, 1],\n    strides=[\n        2,\n        2,\n    ],  # Default values for other attributes: dilations=[1, 1], groups=1\n)\ny_with_padding = np.array(\n    [\n        [\n            [\n                [12.0, 27.0, 24.0],  # (1, 1, 4, 3) output tensor\n                [63.0, 108.0, 81.0],\n                [123.0, 198.0, 141.0],\n                [112.0, 177.0, 124.0],\n            ]\n        ]\n    ]\n).astype(np.float32)\nexpect(\n    node_with_padding,\n    inputs=[x, W],\n    outputs=[y_with_padding],\n    name=\"test_conv_with_strides_padding\",\n)\n\n# Convolution with strides=2 and no padding\nnode_without_padding = onnx.helper.make_node(\n    \"Conv\",\n    inputs=[\"x\", \"W\"],\n    outputs=[\"y\"],\n    kernel_shape=[3, 3],\n    pads=[0, 0, 0, 0],\n    strides=[\n        2,\n        2,\n    ],  # Default values for other attributes: dilations=[1, 1], groups=1\n)\ny_without_padding = np.array(\n    [\n        [\n            [\n                [54.0, 72.0],  # (1, 1, 3, 2) output tensor\n                [144.0, 162.0],\n                [234.0, 252.0],\n            ]\n        ]\n    ]\n).astype(np.float32)\nexpect(\n    node_without_padding,\n    inputs=[x, W],\n    outputs=[y_without_padding],\n    name=\"test_conv_with_strides_no_padding\",\n)\n\n# Convolution with strides=2 and padding only along one dimension (the H dimension in NxCxHxW tensor)\nnode_with_asymmetric_padding = onnx.helper.make_node(\n    \"Conv\",\n    inputs=[\"x\", \"W\"],\n    outputs=[\"y\"],\n    kernel_shape=[3, 3],\n    pads=[1, 0, 1, 0],\n    strides=[\n        2,\n        2,\n    ],  # Default values for other attributes: dilations=[1, 1], groups=1\n)\ny_with_asymmetric_padding = np.array(\n    [\n        [\n            [\n                [21.0, 33.0],  # (1, 1, 4, 2) output tensor\n                [99.0, 117.0],\n                [189.0, 207.0],\n                [171.0, 183.0],\n            ]\n        ]\n    ]\n).astype(np.float32)\nexpect(\n    node_with_asymmetric_padding,\n    inputs=[x, W],\n    outputs=[y_with_asymmetric_padding],\n    name=\"test_conv_with_strides_and_asymmetric_padding\",\n)"
              }
            ],
            "category": "Layer"
          }
        }
      ]
    }
  ]
}